# vnctst-audio3 仕様書

これは、vnctst-audio3同様の音源ライブラリを開発したいと思う人の為に、vnctst-audio3の仕様の概要を書き記したものです。


## 目次

- [用語/概念](#用語概念)
- [構造概要](#構造概要)
- [SE仕様概要](#SE仕様概要)
- [BGM仕様概要](#BGM仕様概要)
- [環境固有の要件への対応](#環境固有の要件への対応)
- [デバイス概要](#デバイス概要)
- [デバイス種別](#デバイス種別)
- [BGMの状態遷移](#)BGMの状態遷移
- [付録](#付録)


## 用語/概念

- BGM, BGS, ME, SE : [README.md](README.md) を参照。
    - なお、単に「BGM」と言った場合でも、BGMだけでなくBGSとMEを含む意味で言っているケースがある(内部処理の分類としては「BGM/BGS/ME」「SE」の二種に分かれる為)。

- device, (再生)デバイス : 物理的なデバイスではなく、WebAudioやHtmlAudio等(のラッパー層)を指す語。
    - デバイス層は低レベルの機能だけを提供する。提供する機能の詳細は後述。
    - デバイス種別についても後述。これは後から追加が可能(ただし追加インターフェース等は今のところ外部に公開はしていない)。

- audio-source, as, 音源ソース : urlからロードされた音源データ。
  この実体はdeviceによってまちまちだが、単一のmapとして表現される。

- audio-channel, ac, channel, 再生チャンネル : 再生可能なインスタンス。
  この実体もdeviceによってまちまちだが、mapの入ったatomとして表現される。
    - acのインスタンスは、asから生成される。複数個の生成も可能。
    - 別々のacを同時に再生する事で「BGMとSEを同時に鳴らす」ような事を実現する。
      勿論、同一のasから生成した複数のacを多重に再生する事も可能。
    - acは再生後にもう一度再生したり、再生中に巻き戻したり、
      再生パラメータを変更したりできる。
        - ただし、SEとしては「一度再生が完了したSEを再度再生する」操作は提供していない(これを提供すると色々と厄介な問題がある為)。これはBGM用としての機能。


## 構造概要

内部は「インターフェース層」「BGM部」「SE部」「デバイス層」に分かれている。

- インターフェース層は、ユーザへ提供する関数等をまとめてある。
    - `vnctst.audio3` 名前空間が相当。

- BGM部は、現在再生中のBGM/BGS/MEの管理(フェードインアウトや次の曲のキューイング等)を行う。SE部とは全然性質が違う。
    - `vnctst.audio3.bgm` 名前空間が相当。

- SE部は、SEの管理を行う。BGM部とは全然性質が違う。
    - `vnctst.audio3.se` 名前空間が相当。

- デバイス層は、各環境で異なる、低レベルの音響再生エンジンを抽象化したもの
    - デバイスは現在のところ「dumb(無音)」「WebAudio」「HtmlAudio(同一SE単一)」「HtmlAudio(同一SE多重)」の四種類が提供されている。
    - 各デバイスは共通の、必要最小限のインターフェースを持つ。 `vnctst.audio3.device.entry-table` 名前空間にこれらの定義がある。
        - 具体的には、前述のasやacを提供する事になる。
    - BGM部とSE部は、それぞれ個別にこれらのデバイスを実行する。
        - BGM部とSE部とで、違うデバイスを同時に使える必要がある。これは、androidのchromeのWebAudioのデコード処理が異様に重い為、SEぐらいならデコードできるが長いBGMだとデコード部分で処理が固まってしまう問題があり、その回避方法として「SEはWebAudioで再生するが、BGMはHtmlAudioで再生する」必要がある為。

上記以外に「状態保持」「プリセット管理」「その他ユーティリティ」等の名前空間もあるが、処理の本質にはあまり関わらないので割愛する。


## SE仕様概要

- 基本的には「プリロードがまだならasを生成/保持する事でプリロードとし、そこから再生する毎にacを生成し、再生が完了したら適宜disposeする」だけでよい。
    - 「再生途中のSEを停止する」処理の為に、SEを個別に指定して停止できる必要がある
        - プリロードがまだの時に再生しようとした場合、先にプリロードを行い、プリロードが完了されてから予約していた再生を行う必要があるが、プリロード中はasもacもないので、前述の「SE個別指定停止」を実現するには、上手くカプセル化して扱う必要がある(要はPromise的な処理が必要となる)

- 同じタイムスライス中に同一SEを複数回再生すると音割れの原因となるので、一定時間中に同一SEを再生しようとした場合は無効化する処理を入れている。


## BGM仕様概要

- BGM系はプリロード、フェード処理、および次の曲の予約管理が必要となる

- BGMの再生とMEの再生は同じ一つのインスタンス(ステート)で管理される。BGSはそれとは違う別のインスタンス(ステート)で管理される
    - ここでは、これを「BGMステート」「BGSステート」と呼ぶ事にする
    - これによって「BGM(もしくはME)と同時に、BGSを鳴らす」事を実現している

- BGMステートおよびBGSステートは、以下の機能を持つ
    - フェードアウト/フェードイン
    - 次に再生する曲の予約処理(プリロードやフェードアウト後に再生する事になる為)

- 非常に複雑な状態遷移を持つ。詳細は後述

- BGMのプリロードについて
    - SEとは違い、BGMはデータ量が多くメモリ使用量が大きくなりがちなので、単に「未プリロードの曲を再生」しようとしただけではプリロードは行わない。これは「再生の為にasとacを生成するが、再生停止(他の曲への変更も含む)したらasとacを破棄する」という意味。
    - SEとは違い、「未プリロードの曲の再生要求があったので、プリロードを開始したが、別の曲の再生要求がすぐに来たので、現在のプリロードはキャンセルして別の曲の方を処理する」という事がありえる。これに適切に対応できなくてはならない。

- フェードインアウトへの対応について
    - フェードインアウトは途中でキャンセルがある為、WebAudioのようにネイティブにフェードをサポートしているものであっても、ソフトウェア(定期的に音量自体を変化させる)対応とする。
    - ステート毎に「フェード音量倍率」の情報を保持する
        - 平常時は1.0としておく
        - そのステートでの再生時/音量変更時には常にこれを適用する
        - フェードインアウトは、タイマーによって少しずつこの値を上下させる(と共にacへと適用する)事によって実現する
        - フェードインアウトの完了は、変動後に値が1.0もしくは0.0になった事での判定とする(どちらでの判定になるかはフェードインかフェードアウトかによる)


## 環境固有の要件への対応

- バックグラウンド時に消音してくれる機能(オプションで無効化可能)
    - バックグラウンド消音中でもSEを鳴らせる機能(アラーム用途)

- android版chromeでは、WebAudioの音源ロード(デコード)に異様に時間がかかる問題がある
    - この問題に対しては、「BGM/BGS/MEのみ、WebAudioではなくHtmlAudioでの再生とする」という対策がある
        - SEについてはデータ量が短い事が多い為、WebAudioでも問題ないようだ

- iOS系では「まず最初にタッチ系イベントハンドル内から音を出す処理を行う」必要があり、この処理を行うまでは音の再生は無効化される
    - この処理をここでは「アンロック」と呼ぶ事にする


## デバイス概要

各デバイスは、以下の必要最小限のインターフェース関数を持つ、
クラスのようなものとして定義されている。

(後から動的に追加する事を想定して、クラスそのものでの実装とはしていない)

- 初期化
- (urlからの)asのロード
- asの破棄
- (asからの)acの生成
- (acからの)再生ポジション取得
- (acへの)再生開始
- (acからの)再生状態の取得
- (acへの)再生停止
- (acへの)ボリューム設定(変更)
- (acへの)ピッチ設定(変更)
- (acへの)パン設定(変更)
- acの破棄

それぞれの詳細については `vnctst.audio3.device.entry-table` を参照。

なお、多くのデバイスでは「asの破棄」「acの破棄」は不要だが、一部のデバイスでは必要になる為、用意している。内部では必ずこの破棄関数を実行する必要がある。

(しかしユーザはこれを意識しなくてよい。再生が完了したBGM/BGS/ME/SEは内部にて適切なタイミングで破棄されるので、ユーザからは破棄指示を出さなくてよい(ただしSEに限っては自動プリロードの仕様上メモリに残り続けるので、必要であればユーザが明示的なアンロードを指示しなくてはならない))


## デバイス種別

- `vnctst.audio3.device.dumb` - コンソール出力のみのダミーデバイス
    - WebAudioもHtmlAudioも利用可能でない場合にこれが採用される。もちろん音は出ない。
    - なおデフォルト状態ではコンソール出力もされない。出力されるようにするには、`vnctst.audio3.device.entry-table/device-log-verbose?`を真値に変更する事。

- `vnctst.audio3.device.web-audio` - WebAudioラッパ

- `vnctst.audio3.device.html-audio-single` - HtmlAudioラッパ(単チャンネル再生)
    - モバイル環境を想定した、同一SEの多重再生を行わないタイプ。
    - 同一SEの多重再生リクエストがあった際には、先に鳴っていたSEを停止させてから新しいSEを再生させる。違うSEであれば普通に多重再生できる。

- `vnctst.audio3.device.html-audio-multi` - HtmlAudioラッパ(多チャンネル再生)
    - PC環境を想定した、同一SEの多重再生を行うタイプ。
    - 内部で `vnctst.audio3.device.html-audio-single` を再利用している


## BGMの状態遷移

以下の状態遷移は、BGM/MEステートとBGSステートそれぞれ独立で処理が行われる。

書式は、「」で囲まれているのは状態、『』で囲まれているのはアクション(リクエスト)で、以下のような定義で示される。

> 「ある状態」 ＋ 『あるアクション』 → 「別の状態」になったり、『別のアクション』が実行されたりする

なお、ユーザが起動できる『アクション』は『曲の再生』と『曲の停止』のみだが、それに付随する多くの状態がある(ので非常に複雑)。またユーザの起動しない『アクション』も多数ある。

無再生状態：

- 「無再生状態」 ＋ 『曲の停止』 → 何もしない

- 「無再生状態」 ＋ プリロードされていない『曲の再生』 → 『次の曲としてキューイング』『ロード実行開始』してから「無再生状態/ロード中」へ

- 「無再生状態」 ＋ プリロードされている『曲の再生』 → 『現在の曲としてキューイング』『再生開始』してから「再生中」へ

無再生状態/ロード中：

- 「無再生状態/ロード中」 ＋ 『曲の停止』 → 『キューイングしていた次の曲の消去』および『ロード処理のキャンセル』をしてから「無再生状態」へ
    - 実際には、このタイミングではロード処理のキャンセルはできない事に注意(何故なら、次にロード処理に制御が渡ってくるのはロード完了時である為)。なので、ロード処理毎にキャンセルフラグ変数を用意し、キャンセル時にはそのフラグ変数を変更する事によって、ロードのキャンセルをロード処理に伝える、しかない。

- 「無再生状態/ロード中」 ＋ ロード中と同じ『曲の再生』 → 何もしない

- 「無再生状態/ロード中」 ＋ プリロードされていない、ロード中のとは違う『曲の再生』 → 『キューイングしていた次の曲の消去』をしてから、改めて『次の曲としてキューイング』『ロード実行開始』を行う。状態は「無再生状態/ロード中」のまま

- 「無再生状態/ロード中」 ＋ プリロード済の、ロード中のとは違う『曲の再生』 → 『キューイングしていた次の曲の消去』をしてから、改めて『現在の曲としてキューイング』『再生開始』を行い「再生中」へ

- 「無再生状態/ロード中」 ＋ 『ロードの完了(成功)』 → キャンセルフラグが立っていない事を確認してから改めて『現在の曲としてキューイング』『再生開始』し、「再生中」へ

- 「無再生状態/ロード中」 ＋ 『ロードの完了(エラー)』 → `:debug?`フラグが立っているならログ出力を行う。状態は「無再生状態」に戻す

再生中：

- 「再生中」 ＋ 『曲の停止』 → 「フェードアウト」へ。ただしフェード秒数に0が指定されていた場合のみ即座に『停止処理』を行い「無再生状態」へ

- 「再生中」 ＋ 現在の曲と同じ『曲の再生』 → 何もしない

- 「再生中」 ＋ プリロードされていない、現在の曲とは違う『曲の再生』 → 『次の曲としてキューイング』『ロード実行開始』してから「フェードアウト/ロード中」へ

- 「再生中」 ＋ プリロードされている、現在の曲とは違う『曲の再生』 → 『次の曲としてキューイング』してから「フェードアウト」へ

- 「再生中」 ＋ 『MEの再生完了』 → 「無再生状態」へ

フェードアウト：

- 「フェードアウト」 ＋ 『曲の停止』 → 何もしない。ただしフェード秒数指定が以前と違うなら、残りのフェード速度を新しいパラメータ準拠に変更する

- 「フェードアウト」 ＋ 現在の曲と同じ『曲の再生』 → 現時点のフェードボリュームを考慮しつつ「フェードイン」へ

- 「フェードアウト」 ＋ プリロードされていない、現在の曲とは違う『曲の再生』 → もし既に次の曲がキューイングされていた場合のみ『キューイングしていた次の曲の消去』をしてから、改めて『次の曲としてキューイング』『ロード実行開始』を行い、「フェードアウト/ロード中」へ

- 「フェードアウト」 ＋ プリロードされている、現在の曲とは違う『曲の再生』 → もし既に次の曲がキューイングされていた場合のみ『キューイングしていた次の曲の消去』をしてから、改めて『次の曲としてキューイング』し直す。状態は変化しない

- 「フェードアウト」 ＋ 『フェードアウト完了』 → もし次の曲がキューイングされているなら、次の曲を『現在の曲としてキューイング』『再生開始』を開始して「再生中」へ。しかし次の曲がキューイングされていない場合は「無再生状態」へ

- 「フェードアウト」 ＋ 『MEの再生完了』 → 上記の『フェードアウト完了』時と同じ扱い

フェードアウト/ロード中：

- 「フェードアウト/ロード中」 ＋ 『曲の停止』 → 『キューイングしていた次の曲の消去』を行い、「フェードアウト」へ。またフェード秒数指定が以前と違うなら、残りのフェード速度を新しいパラメータ準拠に変更する

- 「フェードアウト/ロード中」 ＋ 現在の曲と同じ『曲の再生』 → 『キューイングしていた次の曲の消去』を行い、現時点のフェードボリュームを考慮しつつ「フェードイン」へ

- 「フェードアウト/ロード中」 ＋ ロード中の曲と同じ『曲の再生』 → 何もしない

- 「フェードアウト/ロード中」 ＋ プリロードされていない、現在の曲とは違う『曲の再生』 → 『キューイングしていた次の曲の消去』をしてから、改めて『次の曲としてキューイング』『ロード実行開始』を行う。状態は「フェードアウト/ロード中」のまま

- 「フェードアウト/ロード中」 ＋ プリロード済の、ロード中のとは違う『曲の再生』 → 『キューイングしていた次の曲の消去』をしてから、改めて『現在の曲としてキューイング』を行い「フェードアウト」へ

- 「フェードアウト/ロード中」 ＋ 『ロードの完了(成功)』 → 「フェードアウト」へ

- 「フェードアウト/ロード中」 ＋ 『ロードの完了(エラー)』 → `:debug?`フラグが立っているならログ出力を行う。状態は「フェードアウト」へ

- 「フェードアウト/ロード中」 ＋ 『フェードアウト完了』 → 「無再生状態/ロード中」へ

- 「フェードアウト/ロード中」 ＋ 『MEの再生完了』 → 「無再生状態/ロード中」へ

フェードイン：

- 「フェードイン」 ＋ 『曲の停止』 → 現時点のフェードボリュームを考慮しつつ「フェードアウト」へ

- 「フェードイン」 ＋ 現在の曲と同じ『曲の再生』 → 何もしない

- 「フェードイン」 ＋ プリロードされていない、現在の曲とは違う『曲の再生』 → 『次の曲としてキューイング』『ロード実行開始』してから、現時点のフェードボリュームを考慮しつつ「フェードアウト/ロード中」へ

- 「フェードイン」 ＋ プリロードされている、現在の曲とは違う『曲の再生』 → 『次の曲としてキューイング』してから、現時点のフェードボリュームを考慮しつつ「フェードアウト」へ

- 「フェードイン」 ＋ 『フェードイン完了』 → 「再生中」へ

- 「フェードイン」 ＋ 『MEの再生完了』 → 「無再生状態」へ

----

これは非常に分かりにくいが、「実装してみたライブラリがこの通りに状態遷移を網羅しているかどうかの確認」する用途には利用できると思う。


# 付録

## 筆者による、他の音源ライブラリを試した時の感想

- SoundJS, Howler, Buzz - http://doc.tir.ne.jp/misc/karasumaclj/js-libraries#%E9%9F%B3%E6%BA%90%E5%86%8D%E7%94%9F%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA に書いた(2014年頃の情報だが)

- boombox - https://github.com/CyberAgent/boombox.js - 扱いやすいが、標準では同じSEの連打に対応していない。しかしそれ以外は大体問題なく使える為、旧vnctst-audioの内部デバイス部として利用していた



